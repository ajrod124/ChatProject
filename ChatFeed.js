// Generated by CoffeeScript 1.12.2
(function() {
  var ChatFeed, ChatInput, Header, React, ReactNative, ScrollView, ServerContent, ServerSettings, StyleSheet, Text, TextElement, TouchableHighlight, View, bar, moment, styles, urls;

  React = require('react');

  ReactNative = require('react-native');

  moment = require('moment');

  Header = require('./Header');

  ServerSettings = require('./ServerSettings');

  ServerContent = require('./ServerContent');

  ChatInput = require('./ChatInput');

  TextElement = require('./TextElement');

  urls = require('./urls');

  bar = '   \u23af\u23af\u23af\u23af\u23af\u23af\u23af\u23af\u23af\u23af\u23af\u23af\u23af\u23af\u23af    ';

  Text = ReactNative.Text, View = ReactNative.View, StyleSheet = ReactNative.StyleSheet, TouchableHighlight = ReactNative.TouchableHighlight, ScrollView = ReactNative.ScrollView;

  ChatFeed = React.createClass({displayName: "ChatFeed",
    getInitialState: function() {
      return {
        name: null,
        messages: [],
        textBoxes: [],
        allowInput: false,
        selectedChannel: 0
      };
    },
    componentWillMount: function() {
      this.counter = 0;
      this.prevMessage = null;
      this.populateText(this.props.channel);
      this.ws = new WebSocket(urls.socketServer);
      return this.setupSocket();
    },
    componentWillReceiveProps: function(nextProps) {
      if ((this.state.name != null) && this.state.name !== nextProps.channel.name) {
        this.counter = 0;
        this.prevMessage = null;
        return this.populateText(nextProps.channel);
      }
    },
    populateText: function(channel) {
      var messages;
      messages = channel.messages;
      return this.setState({
        name: channel.name,
        messages: messages,
        textBoxes: messages.map(this.renderRow)
      });
    },
    setupSocket: function() {
      this.ws.onopen = (function(_this) {
        return function() {
          return _this.setState({
            allowInput: true
          });
        };
      })(this);
      this.ws.onmessage = (function(_this) {
        return function(e) {
          var obj;
          obj = JSON.parse(e.data);
          switch (obj.type) {
            case 'chatEvent':
              if (obj.name === _this.state.name) {
                return _this.updateFeed({
                  userId: obj.userId,
                  time: obj.time,
                  message: obj.message
                });
              }
              break;
            default:
              return console.log('Unexpected response from socket server: ', obj);
          }
        };
      })(this);
      return this.ws.onclose = (function(_this) {
        return function(e) {
          return console.log(e);
        };
      })(this);
    },
    renderRow: function(message, i) {
      var displayExtra, renderDivider;
      renderDivider = (this.prevMessage == null) || !moment(this.prevMessage.time).isSame(message.time, 'day');
      displayExtra = this.shouldDisplayExtra(message, i);
      if (renderDivider) {
        return React.createElement(View, {
          "key": i
        }, React.createElement(Text, {
          "style": styles.divider
        }, bar + moment(message.time).format('MMM D, YYYY') + bar), React.createElement(TextElement, {
          "message": message,
          "users": this.props.users,
          "displayExtra": displayExtra
        }));
      } else {
        return React.createElement(TextElement, {
          "key": i,
          "message": message,
          "users": this.props.users,
          "displayExtra": displayExtra
        });
      }
    },
    shouldDisplayExtra: function(message, i) {
      if (this.prevMessage == null) {
        this.prevMessage = message;
        this.counter++;
        return true;
      }
      if (message.time - this.prevMessage.time > 3600000 || message.userId !== this.prevMessage.userId) {
        this.counter = 0;
      } else {
        this.counter++;
      }
      this.prevMessage = message;
      return this.counter % 6 === 0;
    },
    scrollToBottom: function(contentWidth, contentHeight) {
      return this.messageBox.scrollTo({
        y: contentHeight,
        animated: true
      });
    },
    addMessage: function(message) {
      var time, userId;
      time = (new Date()).getTime();
      userId = '58932274f36d2863007a8c2d';
      return this.ws.send(JSON.stringify({
        type: 'chatEvent',
        name: this.state.name,
        userId: userId,
        time: time,
        message: message
      }));
    },
    updateFeed: function(message) {
      var array;
      array = this.state.messages.slice();
      array.push(message);
      this.props.updateChannel(this.state.name, message);
      return this.setState({
        messages: array,
        textBoxes: array.map(this.renderRow)
      });
    },
    render: function() {
      return React.createElement(View, {
        "style": styles.container
      }, React.createElement(Header, {
        "name": this.state.name,
        "openLeft": this.props.openLeft,
        "openRight": this.props.openRight,
        "navigator": this.props.navigator
      }), React.createElement(ScrollView, {
        "ref": ((function(_this) {
          return function(ref) {
            return _this.messageBox = ref;
          };
        })(this)),
        "onContentSizeChange": this.scrollToBottom
      }, this.state.textBoxes), React.createElement(ChatInput, {
        "name": this.state.name,
        "editable": this.state.allowInput,
        "onSubmit": this.addMessage
      }));
    }
  });

  styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: '#222222',
      elevation: 1
    },
    divider: {
      paddingBottom: 9,
      alignSelf: 'center',
      fontSize: 10,
      color: '#444444'
    }
  });

  module.exports = ChatFeed;

}).call(this);
